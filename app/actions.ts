"use server";

import { Config, configSchema, explanationsSchema, Result } from "@/lib/types";
import { openai } from "@ai-sdk/openai";
import { sql } from "@vercel/postgres";
import { generateObject } from "ai";
import { z } from "zod";
import dotenv from "dotenv";
import { Pool } from "pg";
dotenv.config();


export const generateQuery = async (input: string) => {
  "use server";
  try {
  
    const result = await generateObject({
      model: openai("gpt-4o"),
      system: `You are a SQL (postgres) and data visualization expert. Your job is to help the user write a SQL query to retrieve the data they need. Whenever an amount is mentions, such as amount, total_amount, recurring_amount, its in cents, so it needs to be devided by 100. The table schemas are as follows:

      donations (
  id uuid not null default gen_random_uuid (),
  stripe_pid text not null,
  nonprofit_id text null,
  total_amount integer null,
  currency text null,
  status text null,
  created_at timestamp without time zone null,
  donor_id text null,
  recurring text null,
  payment_method text null,
  application_fee integer null,
  adjusted_amount integer null,
  card_brand text null,
  card_last4 integer null,
  cover_fee boolean null,
  suggested_amount boolean null,
  constraint donations_pkey primary key (id),
  constraint donations_stripe_tx_id_key unique (stripe_pid),
  constraint donations_donor_id_fkey foreign KEY (donor_id) references donors (donor_id) on update CASCADE,
  constraint donations_nonprofit_id_fkey foreign KEY (nonprofit_id) references nonprofits (connected_account_id)
);

donors (
  id bigint generated by default as identity not null,
  created_at timestamp without time zone not null,
  name text null,
  email text null,
  address text null,
  donor_id text not null,
  card_brand text null,
  card_last4 integer null,
  constraint donors_pkey primary key (id),
  constraint donors_donor_id_key unique (donor_id)
);

nonprofits (
  id uuid not null,
  name text null,
  connected_account_id text null,
  created_at timestamp with time zone not null default now(),
  constraint nonprofits_pkey primary key (id),
  constraint nonprofits_connected_account_id_key unique (connected_account_id),
  constraint nonprofits_id_fkey foreign KEY (id) references auth.users (id)
);

post_donation_data (
  id bigint generated by default as identity not null,
  donation_pid text null,
  created_at timestamp with time zone not null default now(),
  gift_destination text null,
  topic_interest text null,
  inspiration text null,
  phone_number text null,
  birthday date null,
  will_interest boolean null,
  constraint post_donation_data_pkey primary key (id),
  constraint post_donation_data_donation_id_key unique (donation_pid),
  constraint post_donation_data_donation_pid_fkey foreign KEY (donation_pid) references donations (stripe_pid)
);

recurring (
  id bigint generated by default as identity not null,
  donation_id uuid null,
  recurring_amount integer null,
  donor_id text null,
  sub_id text null,
  start_date timestamp without time zone null,
  next_payment_date timestamp without time zone null,
  last_invoice_id text null,
  created_at timestamp without time zone null default now(),
  updated_at timestamp without time zone null,
  status text null,
  payments integer null,
  constraint recurring_pkey primary key (id),
  constraint recurring_id_key unique (id),
  constraint recurring_donation_id_fkey foreign KEY (donation_id) references donations (id),
  constraint recurring_donor_id_fkey foreign KEY (donor_id) references donors (donor_id),
  constraint recurring_last_invoice_id_fkey foreign KEY (last_invoice_id) references donations (stripe_pid)
);

    Only retrieval queries are allowed.

    For things like donor names, nonprofit names and other string fields, use the ILIKE operator and convert both the search term and the field to lowercase using LOWER() function. For example: LOWER(industry) ILIKE LOWER('%search_term%').
    Remember to convert the amounts to dollars by deviding by 100.
    EVERY QUERY SHOULD RETURN QUANTITATIVE DATA THAT CAN BE PLOTTED ON A CHART! There should always be at least two columns. If the user asks for a single column, return the column and the count of the column. If the user asks for a rate, return the rate as a decimal. For example, 0.1 would be 10%.
    `,
      prompt: `Generate the query necessary to retrieve the data the user wants: ${input}`,
      schema: z.object({
        query: z.string(),
      }),
    });
    console.log(result.object.query)
    if (
      !result.object.query.trim().toLowerCase().startsWith("select") 
    ) {console.log("Query is not a SELECT statement!")}
    if (
      result.object.query.trim().toLowerCase().includes(" drop ") 
    ) {console.log("Query is a DROP statement!")}
    if (
      result.object.query.trim().toLowerCase().includes(" delete ") 
    ) {console.log("Query is a DELETE statement!")}
    if (
      result.object.query.trim().toLowerCase().includes(" insert ") 
    ) {console.log("Query is a INSERT statement!")}
    if (
      result.object.query.trim().toLowerCase().includes(" update ") 
    ) {console.log("Query is a UPDATE statement!")}
    if (
      result.object.query.trim().toLowerCase().includes(" alter ") 
    ) {console.log("Query is an ALTER statement!")}
    if (
      result.object.query.trim().toLowerCase().includes(" truncate ")
    ) {console.log("Query is a TRUNCATE statement!")}
    if (
      result.object.query.trim().toLowerCase().includes(" create ") 
    ) {console.log("Query is a CREATE statement!")}
    if (
      result.object.query.trim().toLowerCase().includes(" grant ") 
    ) {console.log("Query is a GRANT statement!")}
    if (
      result.object.query.trim().toLowerCase().includes(" revoke ")
    ) {console.log("Query is a REVOKE statement!")}
    return result.object.query.trim();

  } catch (e) {
    console.error(e);
    throw new Error("Failed to generate query");
  }
};

export const runGenerateSQLQuery = async (query: string) => {
  "use server";
  // Check if the query is a SELECT statement
  if (
    !query.trim().toLowerCase().startsWith("select") ||
    query.trim().toLowerCase().includes(" drop ") ||
    query.trim().toLowerCase().includes(" delete ") ||
    query.trim().toLowerCase().includes(" insert ") ||
    query.trim().toLowerCase().includes(" update ") ||
    query.trim().toLowerCase().includes(" alter ") ||
    query.trim().toLowerCase().includes(" truncate ") ||
    query.trim().toLowerCase().includes(" create ") ||
    query.trim().toLowerCase().includes(" grant ") ||
    query.trim().toLowerCase().includes(" revoke ")
  ) {
    throw new Error("Only SELECT queries are allowed");
  }
  const pool = new Pool({
    connectionString: process.env.POSTGRES_URL, // Make sure this is your Supabase URL
    ssl: { rejectUnauthorized: false }, // Required for Supabase
  });
  let data: any;
  try {
    const client = await pool.connect();
    data = await client.query(query);
  } catch (e: any) {
    if (e.message.includes('relation "unicorns" does not exist')) {
      console.log(
        "Table does not exist, creating and seeding it with dummy data now..."
      );
      // throw error
      throw Error("Table does not exist");
    } else {
      throw e;
    }
  }

  return data.rows as Result[];
};

export const explainQuery = async (input: string, sqlQuery: string) => {
  "use server";
  try {
    const result = await generateObject({
      model: openai("gpt-4o"),
      schema: z.object({
        explanations: explanationsSchema,
      }),
      system: `You are a SQL (postgres) expert. Your job is to explain to the user write a SQL query you wrote to retrieve the data they asked for. The table schema is as follows:
  donations (
  id uuid not null default gen_random_uuid (),
  stripe_pid text not null,
  nonprofit_id text null,
  total_amount integer null,
  currency text null,
  status text null,
  created_at timestamp without time zone null,
  donor_id text null,
  recurring text null,
  payment_method text null,
  application_fee integer null,
  adjusted_amount integer null,
  card_brand text null,
  card_last4 integer null,
  cover_fee boolean null,
  suggested_amount boolean null,
  constraint donations_pkey primary key (id),
  constraint donations_stripe_tx_id_key unique (stripe_pid),
  constraint donations_donor_id_fkey foreign KEY (donor_id) references donors (donor_id) on update CASCADE,
  constraint donations_nonprofit_id_fkey foreign KEY (nonprofit_id) references nonprofits (connected_account_id)
);

donors (
  id bigint generated by default as identity not null,
  created_at timestamp without time zone not null,
  name text null,
  email text null,
  address text null,
  donor_id text not null,
  card_brand text null,
  card_last4 integer null,
  constraint donors_pkey primary key (id),
  constraint donors_donor_id_key unique (donor_id)
);

nonprofits (
  id uuid not null,
  name text null,
  connected_account_id text null,
  created_at timestamp with time zone not null default now(),
  constraint nonprofits_pkey primary key (id),
  constraint nonprofits_connected_account_id_key unique (connected_account_id),
  constraint nonprofits_id_fkey foreign KEY (id) references auth.users (id)
);

post_donation_data (
  id bigint generated by default as identity not null,
  donation_pid text null,
  created_at timestamp with time zone not null default now(),
  gift_destination text null,
  topic_interest text null,
  inspiration text null,
  phone_number text null,
  birthday date null,
  will_interest boolean null,
  constraint post_donation_data_pkey primary key (id),
  constraint post_donation_data_donation_id_key unique (donation_pid),
  constraint post_donation_data_donation_pid_fkey foreign KEY (donation_pid) references donations (stripe_pid)
);

recurring (
  id bigint generated by default as identity not null,
  donation_id uuid null,
  recurring_amount integer null,
  donor_id text null,
  sub_id text null,
  start_date timestamp without time zone null,
  next_payment_date timestamp without time zone null,
  last_invoice_id text null,
  created_at timestamp without time zone null default now(),
  updated_at timestamp without time zone null,
  status text null,
  payments integer null,
  constraint recurring_pkey primary key (id),
  constraint recurring_id_key unique (id),
  constraint recurring_donation_id_fkey foreign KEY (donation_id) references donations (id),
  constraint recurring_donor_id_fkey foreign KEY (donor_id) references donors (donor_id),
  constraint recurring_last_invoice_id_fkey foreign KEY (last_invoice_id) references donations (stripe_pid)
);

    When you explain you must take a section of the query, and then explain it. Each "section" should be unique. So in a query like: "SELECT * FROM donors limit 20", the sections could be "SELECT *", "FROM DONORS", "LIMIT 20".
    If a section doesnt have any explanation, include it, but leave the explanation empty.

    `,
      prompt: `Explain the SQL query you generated to retrieve the data the user wanted. Assume the user is not an expert in SQL. Break down the query into steps. Be concise.

      User Query:
      ${input}

      Generated SQL Query:
      ${sqlQuery}`,
    });
    return result.object;
  } catch (e) {
    console.error(e);
    throw new Error("Failed to generate query");
  }
};

export const generateChartConfig = async (
  results: Result[],
  userQuery: string
) => {
  "use server";
  const system = `You are a data visualization expert. `;

  try {
    const { object: config } = await generateObject({
      model: openai("gpt-4o"),
      system,
      prompt: `Given the following data from a SQL query result, generate the chart config that best visualises the data and answers the users query.
      For multiple groups use multi-lines.

      Here is an example complete config:
      export const chartConfig = {
        type: "pie",
        xKey: "month",
        yKeys: ["donations", "amounts", "donors"],
        colors: {
          donation: "#4CAF50",    // Green for donations
          amounts: "#2196F3",   // Blue for amounts
          donors: "#F44336"  // Red for donors
        },
        legend: true
      }

      User Query:
      ${userQuery}

      Data:
      ${JSON.stringify(results, null, 2)}`,
      schema: configSchema,
    });

    const colors: Record<string, string> = {};
    config.yKeys.forEach((key, index) => {
      colors[key] = `hsl(var(--chart-${index + 1}))`;
    });

    const updatedConfig: Config = { ...config, colors };
    return { config: updatedConfig };
  } catch (e) {
    // @ts-expect-errore
    console.error(e.message);
    throw new Error("Failed to generate chart suggestion");
  }
};
